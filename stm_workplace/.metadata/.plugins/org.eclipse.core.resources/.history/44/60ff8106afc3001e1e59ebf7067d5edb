/*
 * flow_controller.c
 *
 *  Created on: Dec 17, 2023
 *      Author: Juan Lopez
 */

#include "main.h"
#include "flow_controller.h"

#include <string.h>	// used for UART printing
#include <math.h> 	// used for rounding

// Private variables	------------------------------------------------//

// Analog Variables
//uint32_t dacBitVal;	// DAC outputs voltage = 12-bit value
//uint16_t adcBitVal; // ADC returns voltage = 12-bit value
//float adcVolts = 0;		// adcBitVal converted into volts
//const uint8_t ADCSAMPLESIZE = 5;
float instFlow = 0;


// Pins
// PA0, input pin DI1
GPIO_InitTypeDef FlowMethodPin = {GPIO_PIN_1, GPIO_MODE_INPUT, GPIO_NOPULL, 0, 0};
GPIO_TypeDef * FlowMethodGroup = GPIOA;
// PA1, input pin DI2
GPIO_InitTypeDef ContactDI2Pin = {GPIO_PIN_3, GPIO_MODE_INPUT, GPIO_NOPULL, 0, 0};
GPIO_TypeDef * ContactDI2Group = GPIOA;
// PA2, input pin DI3
GPIO_InitTypeDef ContactDI3Pin = {GPIO_PIN_5, GPIO_MODE_INPUT, GPIO_NOPULL, 0, 0};
GPIO_TypeDef * ContactDI3Group = GPIOA;


// Static Functions Declaration	----------------------------------------//


// Public Functions		------------------------------------------------//
//void dacSet(DAC_HandleTypeDef *dac, uint32_t channel, float volts){
//	HAL_DAC_Start(dac, channel);
//	dacBitVal = (volts/3.3)*4095;
//	HAL_DAC_SetValue(dac, channel, DAC_ALIGN_12B_R, dacBitVal);
//}

//float adcFiltered(ADC_HandleTypeDef *hadc1){
//	float arr[ADCSAMPLESIZE];
//	float temp;
//	int i, j,k;
//
//	// take 5 samples
//	for(i = 0; i < ADCSAMPLESIZE; i++){
//		arr[i] = adcGet(hadc1);
//		HAL_Delay(1);
//	}
//
//	// insertion sort
//	for(j = 1; j < ADCSAMPLESIZE; j++){
//		temp = arr[j];
//		k = j-1;
//
//		while(k>=0 && arr[k] > temp){
//			arr[k+1] = arr[k];
//			k = k -1;
//		}
//		arr[k+1] = temp;
//	}
//
//	// take the medium
//	//adcVolts =roundf(arr[2] *100.0)/100;
//	adcVolts = arr[2];
//	return adcVolts;
//}

//float readFlow(ADC_HandleTypeDef *hadc1)
//{
//	// 5-0V 10 L/min=250 mV
//	// voltage divider  R2=10k, R1=5.1k
//	// .75 = 0, 0.88 = 10}
//	//adcFiltered(hadc1);
//	adcGet(hadc1);
//	// instFlow = adcVolts * (10.0+5.1)/10.0 / 0.025;	// 0.025V = 1 L/min
//	//float prev = instFlow;
//	instFlow = (adcVolts - 0.64)/  0.013;
//	/*if(fabs(instFlow - prev) < 0.7){
//		instFlow = prev;
//	}
//	instFlow = roundf(instFlow);*/
//	return instFlow;
//}

void flowControllerADC(ADC_HandleTypeDef* hadc){
	ADC_ChannelConfTypeDef sConfig = {0};

	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;

	if (HAL_ADC_ConfigChannel(hadc, &sConfig) != HAL_OK)
	{
	  Error_Handler();
	}
	return;
}
float readFlow(float voltage)
{
	instFlow = (voltage - 0.63)/  0.013;
	return instFlow;
}

void flowRateMethod(uint8_t method){

	// This is PA_0
	// 0 = "Tri-State"
	// 1 = "Gnd"
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	GPIO_InitStruct.Pin = GPIO_PIN_1;
	GPIO_InitStruct.Pull = GPIO_NOPULL;

	if(method == 0){
		GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	} else{
		GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	}
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);	// This must change


	/*
	// This needs to be tested
	if(method == 0){
		FlowMethodPin.Mode = GPIO_MODE_INPUT;
	} else{
		FlowMethodPin.Mode = GPIO_MODE_OUTPUT_PP;
	}
	HAL_GPIO_Init(FlowMethodGroup, &FlowMethodPin);
*/
}

void flowRateSP(uint8_t setPoint){
	// test this function
	switch(setPoint){
	case(0):
			ContactDI2Pin.Mode = GPIO_MODE_INPUT;
			ContactDI3Pin.Mode = GPIO_MODE_INPUT;
			HAL_GPIO_Init(ContactDI2Group, &ContactDI2Pin);
			HAL_GPIO_Init(ContactDI3Group, &ContactDI3Pin);
			break;
	case(1):
			ContactDI2Pin.Mode = GPIO_MODE_OUTPUT_PP;;
			ContactDI3Pin.Mode = GPIO_MODE_INPUT;
			HAL_GPIO_Init(ContactDI2Group, &ContactDI2Pin);
			HAL_GPIO_Init(ContactDI3Group, &ContactDI3Pin);
			break;
	case(2):
			ContactDI2Pin.Mode = GPIO_MODE_INPUT;
			ContactDI3Pin.Mode = GPIO_MODE_OUTPUT_PP;;
			HAL_GPIO_Init(ContactDI2Group, &ContactDI2Pin);
			HAL_GPIO_Init(ContactDI3Group, &ContactDI3Pin);
			break;
	case(3):
			ContactDI2Pin.Mode = GPIO_MODE_OUTPUT_PP;
			ContactDI3Pin.Mode = GPIO_MODE_OUTPUT_PP;
			HAL_GPIO_Init(ContactDI2Group, &ContactDI2Pin);
			HAL_GPIO_Init(ContactDI3Group, &ContactDI3Pin);
			break;
	default:
			ContactDI2Pin.Mode = GPIO_MODE_INPUT;
			ContactDI3Pin.Mode = GPIO_MODE_INPUT;
			HAL_GPIO_Init(ContactDI2Group, &ContactDI2Pin);
			HAL_GPIO_Init(ContactDI3Group, &ContactDI3Pin);
			break;
	}
}


// Static Functions		------------------------------------------------//

